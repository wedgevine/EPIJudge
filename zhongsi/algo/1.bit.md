## bit operation 
bitwise operation, bit manipulation, 位操作, 位运算

### python int 2's complement binary representation
for 0 and every positive number, 2's complement notation is the same as its 
classical binary representation
for negative number, -x is represented by bit pattern of (x-1), then with
all the bits complemented (switch from 1 to 0 and 0 to 1)
so -1 is repsented as 1111 (if we use 4 bits as limit)
since there is no bit limit for python 3 int, it can be written as ...111..1,
unlimited 1s
for the same reason, there are unlimited 0s in the beginning of positive int,
like 5 could be ...000..01001

https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html
https://stackoverflow.com/questions/1049722/what-is-2s-complement

2's complement is just a representation, int in python3 has no limit,
it is implemented as an object, inside the object, an array was used
to store every digit of the int.
the unlimited 2's complement representation is useful for bit operation,
but if want to use this representation for +-*/, there must have some
limit, so for many algo problems, we can assume int involved is within
range [-pow(2, 31), pow(2, 31) - 1], the int range a 32 bit binary can
represent, or [0, pow(2, 32) - 1] if we only care about unsigned int.
so for any int a, a & 0xFFFFFFFF results in a 32 bit int 

### bitwise operator
* x << y, shift to the left by y bits (new bits are 0s), like x * pow(2, y)
* x >> y, shift to the right by y bits, like x // pow(2, y), // is floor division
* x & y, bitwise and
* x | y, bitwise or
* ~x, complement of x, switch each bit to its complement, 1 to 0 and 0 to 1
* x ^ y, bitwise exclusive or, each bit of the output is the same as corresponding
bit in x if that bit in y is 0, and is the complement of the bit of x if that
bit in y is 1

all operations should apply communtative and associative properties

positive and negative, consider their 2's complement representation
* << and >> don't change int positive or negative
* positive & negative results positive
* positive | negative results negative
* ~x actually equals -(x + 1)
* positive ^ negative results negative

https://wiki.python.org/moin/BitwiseOperators

### trick
1. clear the lowest set bit   
   x = 0b1..10..0, x - 1 = 0b1..01..1, then x & (x - 1)
2. extract the lowest set bit   
   x = 0b1..10..0, x - 1 = 0b1..01..1, ~(x - 1) = 0b0..10..0, then x & ~(x - 1)
   note by definition, -x = ~(x - 1), so x & (-x)it means ~x = -(x + 1)
3. set the lowermost 0   
   x = 0b1..101..1, x + 1 = 0b1..110..0, then x | (x + 1)
4. right propagate the rightmost set bit  
   x = 0b1..110..0, x - 1 = 0b1..101..1, x ^ (x - 1) = 0b0..011..1, then x ^ (x - 1) | x
5. compute x modulo a power of 2  
   y = 0b10..0, power of 2, y = 2 ^ n, equals strip last n bits of x, eqauls x & (y - 1)
6. test x is power of 2  
   x != 0 and x & (x - 1) == 0

http://graphics.stanford.edu/~seander/bithacks.html
https://wiki.python.org/moin/BitManipulation
https://stackoverflow.com/questions/tagged/bit-manipulation
https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit?rq=1  
just search "bit hacks", "bit manipulations

### application

### problem
1. LC191 Number of 1 Bits  
   *return the number of '1' bits in an unsigned integer(Hamming weight)*  
   ***
   trick x & (x - 1) clear the LSB
   ***
1. LC136 Single Number  
   *a non-empty array, every element appears twice except for one, find that single one*  
   ***
   trick x ^ x = 0
   ***
1. LC231 Power of 2  
   *Given an integer, determine if it is power of 2* 
   ***
   trick for power of 2, x > 0 and x & (x - 1) = 0
   ***
1. LC201 Bitwise AND of Numbers Range  
   *Given a range, return bitwise AND of all numbers in the range*  
   ***
   for range [m, n], it equals finding the biggest left part which m and n are equal,
   or shr >> m and n until they are equal           
   ***
1. LC338 Counting Bits  
   *Given a non negative integer n, count number of '1's in every number of range [0, n]*  
   ***
   * consider the relationship between i and i >> 1
   * or consider the relationship between range [0, ..., pow(2, k)] 
   and [pow(2, k) + 1, ..., pow(2, k + 1)]
   ***
1. LC476 Number Complement  
   *Given a positive number, return its complement number, flip bits of binary representation*  
   ***
   create mask, 11..1, then xor number
   ***
1. LC693 Binary Number with Alternating Bits  
   *Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.*  
   ***
   the number must be in format 10101...10 or 101010..101, for any case
   * if and only if (n ^ (n >> 1)) + 1 is power of 2
   * iff n & (n >> 1) == 0 and n & (n >> 2) == (n >> 2)
   ***
1. LC78 Subsets  
   *Given a set of distinct integers, nums, return all possible subsets (the power set)*  
   ***
   like how binary number grows, for any new bit(integer) introduced, repeat history  
   [], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]
   ***
1. LC371 Calculate the sum of two integers a and b  
   *but you are not allowed to use the operator + and -*  
   ***
   since int in python3 is unlimited, there must be some limit for the input a, b, or bit operations
   couldn't be used to replace +/-, a fair assumption is a and b are 32 bit signed integer, within
   range [-pow(2, 31), pow(2, 31) - 1], so a & 0xFFFFFFFFF removed the sign of the int. for unsigned int,
   we can do the following until b is zero, then we can convert the result a back if a is negative (in
   32 bit 2's complement representation, the left most bit is 1)
   ``` 
   a, b = a ^ b, (a & b) << 1
   ```

