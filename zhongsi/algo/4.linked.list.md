* singly linked list, node (data, next), head/tail node
* doubly linked list, node (data, pre, next)
* get kth element in the list is expensive, O(N) time complexity
* insert and delete are O(1) time complexity
  
prototype
```
class ListNode:
    def __init__(self, data=0, next_node=None):
        self.data = data
        self.next_node = next_node
```

basic list apis
```
def search_list(L, key):
    while L and L.data != key:
        L = L.next_node
    return L

def insert_after(node, data):
    new_node = ListNode(data, node.next_node)
    node.next_node = new_node

def delete_after(node):
    # suppose node.next_node != null
    node.next_node = node.next_node.next_node
```

## tip
* sentinel, a special dummy node to make the singly/doubly list circular, for easier deletion and insertion  
  there is no need to check None for head/tail node, there is always a sentinel node existed.
  https://stackoverflow.com/questions/5384358/how-does-a-sentinel-node-offer-benefits-over-null
  https://www.cs.dartmouth.edu/~scot/cs10/lectures/6/6.html
  https://www.quora.com/What-is-the-sentinel-node-in-a-circular-linked-list
* don't fotget to update next for head or tail
* like two pointers in array, linked list has two iterators algo, one slow and one fast, one front and one behind 
* python has no direct implementation for linked list, implement by yourself

## problem
1. EPI7.1 Merge two sorted lists  
   *Given two sorted lists, merge them into one list*
   ***
   keep two pointers, head and tail, let tail move with L1 and L2
1. EPI7.2/LC92 Reverse a singe sublist
   *Given a linked list, int s and f, reverse sublist from s-th node to f-th node, node starts from 1*
   ***
   idea drawing from LC https://leetcode.com/problems/reverse-linked-list-ii/discuss/30709/Talk-is-cheap-show-me-the-code-(and-DRAWING)
   1. create dummy node pointing the head node
   1. locate the start node and pre_start, next_start nodes
   2. from next_start to end node, remove the node, insert it after the pre_start node
   3. done
1. LC206 Reverse a whole singly linked list  
   *Reverse a linked list either iteratively or recursively*
   ***
   thinking about changing pointer directions, starting from the head
1. EPI7.3 Is list cyclic  
   *Given a linked list, find out if it is cyclic, if yes, return the start node*
   ***
   two pointers, one slow, and one fast, if it is cyclic, fast must equals slow at a time  
   if there is cycle, start from any node, find out cycle length  
   let fast ahead of slow pointer by cycle length, when they met, they met at the start node
