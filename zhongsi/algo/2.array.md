## array/list/数组 is one-dimensional container of same type elements.

* given an array A, A[i] can be used to retrieve and update the element in O(1) time.
* appending of an array may result in resizing, if we double the size for every resizing,
the time complexity of appending of an array is amortized to O(1)
* for deletion and insertion of an element at index i, n - i elements need to be moved, 
so the time complexity is O(n)
* so it is better to delete/insert element from the end, not the start

usually we work on the array from one end, processing element one by one, in this process,
we may do something like keep the max/min/sum/count encountered so far, keep record of 
range of element, swap elements, after finishing the process, we should get the result

a benefit of array is we can work on it from both ends, or same end but with multiple pointers, the so called two pointers technique
https://leetcode.com/articles/two-pointer-technique/

also we should try to work on the space of the array itself, to reduce the space complexity
to O(1)

be careful with index handling, unline slice of python, index should never be out of range

when working with array in-place, with moving pointers, thinking the array in partitions,
what left behind of pointers are processed partitions and what before the pointers are
to-be processed partitions, partition processing involves pointers moving, elements swapping
and intermediate result calculation, when all pointers are met/to the end, the processing
is finished and all desired partitions (or results) are generated.

## python list

### initialization
[1, 2, 3], [1] + [0] * 10, list(range(100)), [[1, 2, 3], [3, 4, 5], [7]]
### operations
* len(A), A.append(2), A.remove(2), A.insert(3, 28)
* if a in A (O(n) time complexity)
* B = A, two variables pointed to the same object
* B = list(A), a new object was crreated and pointed by B
* copy and deepcopy
* min(A), max(A), A.reverse() (in-place), reversed(A) (returns an iterator),
* A.sort() (in-place), sorted(A) (returns a copy)
* del A[i] (deletes the i-th element)
* del A[i:j] (deletes the slice)
* slice A[i:j:k]  
A[::-1] returns the reversed list  
A[k:] + A[:k] rotate A by k to the left  
B = A[:] B is a shallow copy of A
### list comprehension
a succinct way to generate list  
[ expression for item in list if conditional ]

## problem
1. LC905 Sort Array By Parity, Segregate Even and Odd numbers  
   *Given an integer array A, reorder it so even numbers appear first, followed by odd number*
   ***
   two pointers, one next_even go forward from 0 and one next_odd go backward from len - 1, swap elements when needed

1. LC75 Sort Colors, Dutch national flag problem  
   *Given a 3-value (denote 3 colors) array, sort the array (in-place) so that same color
   are adjacent; or given an integer array and a pivot number, sort the array so that all 
   elements less than pivot appear first, then elements equal pivot number, followed by
   elements greater than the pivot*
   ***
   thinking the array in partitions, red, blue, undecided, white, using pointers record
   positions between red and blue, blue and undecided, undecided and white, let pointers
   move and swap elements when needed
1. LC167 Two Sum for sorted array  
   *Given a sorted array and a target sum, return indexes of two element added up to target*
   ***
   two pointers, one from start, one from end, compare their sum with target, moving
   pointers based on the comparison
1. LC169 Majority Element  
   *Given an array of size n, find majority element which appears more than n/2 times*
   ***
   naviagte the array, keeping record of candidate value and count of candidate appearance,
   count++ if candidate, count-- if not candidate, when finished, what left is the majority
   element
1. LC53 Maximum Subarray  
   *Given an integer array, find the contiguous subarray with largest sum*
   ***
   navigate the array, keeping record of max_sum and subarray_start, subarray_total, if
   the subarray_total is negative, reset subarray using current index, if not, compare
   with max_sum and assign it accordingly
1. LC88 Merge Sorted Arrays  
   *Merge two sorted arrays as one in-place, suppose the first array has enough space*
   ***
   two pinters point to the end of both arrays, move the current larger element to the end
1. LC26 Remove Duplicates from Sorted Array  
   *Given a sorted array, remove duplicates in-place*
   ***
   navigate the array, keeping record of the position of last distinct element found, whenever find a new element, put it after the position and update the position. it
   in fact uses two pointers
1. LC80 Remove Duplicates from Sorted Array II  
   *As above, but duplicates can appear twice*
   ***
   same as above, keeping an additional record already_twice, if it is false, move the pointer and set already_twice true, else don't move the pointer  

   a two-pointer solution:
   ```
   i = 0
   for n in nums:
       if (i < 2) or (n > nums[i - 2]):
           nums[i] = n
           i += 1
   ```
1. LC27 Remove Element  
   *Given an array and val, remove all instances of val in-place and return new length*
   ***
   thinking in partitions, partition1, elements not equal to val, partition2, 
   not-processed elements, partition3, elements equal to val, two pointers, head
   pointing the start of partition2 and tail pointing the end of the partition2, 
   if pointer1 = val, swap element between pointers, else forwarding  
   or the following two-pointer solution:
   ```
   i = 0
   for n in nums:
       if n != val:
           nums[i] = n
           i += 1
   ```
   but the first solution has better performance when elements equal val are rare,
   only if it is necessary we do the swap






