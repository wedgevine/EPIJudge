
* chr() function convert integer to char, chr(ord('0') + i)
* ord() function convert char to integer, ord(c) - ord('0')
* str.isalnum() and str.upper(), str.lower() functions
* functools.reduce() can be used to replace loop

## problem
1. EPI6.1 Convert between string and int  
   *convert from string to int and from int to string*
   ***
   string to int, read one digit a time, multiple 10 for existing and add the new digit  
   int to string, need an array for all the digit, module to get the ones digit and divide the existing by 10  
   corner case, negative and zero
1. EPI6.2 Base conversion  
   *convert string in base b1 to string in base b2*
   ***
   read the string in b1 base into a integer in decimal, convert the decimal into b2 base string
1. EPI6.3 Compute spreadsheet column encoding  
1. *change int to spreadsheet encoding like 'AA', 'ZZZ'*
   ***
   base 26 encoding, using digit A, B, C, .., Z
   all the above involves place value(positional notation, 位值记数法), also chr() and ord() functions
1. EPI6.4 Replace and remove  
   *given string s and int size, replce 'a' with 2 'd' and remove 'b' for all first size chars of the string, return the processed string length*
   ***
   if the string has no 'a' or 'b', nothing need to be done, if just has 'a', just increase the string, if just has 'b', decrease the string
   the solution is combine both methods, first iteration forward to delete all 'b', then iteration backward to replace all 'a' with 2 'd's.
   this forward scan and figure out final size technique also can be used in telex encoding problem, that is, a string of letters, numbers and marks,
   need to encoding marks of the string, like '.' with 'DOT', ',' with 'COMMA', etc. the idea is iterate forward to figure out the final size and
   copy/encode the string from end
1. EPI6.5/LC125 Test Palindromicity  
   *given a string, with all nonalphanumeric removed, test if it is palindromic*
   ***
   two pointers, one from head, another from tail, use function isalnum and lower
1. LC9 Palindrome number  
   *determined weather an int is a palindrome*
   ***
   reverse the int and compare value, negative is not 
1. LC680 Valid Palindrome II  
   *given a non-empty string, may delete at most one char, judge weather you can make is palindrome*
   ***
   two pointers, also record the first difference (head, tail positions), try skip head or tail to see if it is palindrome
   or recursive solution, create function is_palindrome(s) like in simple palindrome, then
   in main loop, if s[head] != s[tail], try is_palindrome(s[head+1 : tail+1]) and is_palindrome(s[head : tail])  
1. EPI6.6 Reverse words of string  
   *Given a string of words sperated by whitespace, transfer the string that words are in reverse order*
   ***
   like "Replace and remove", two passes are needed, first reverse the string, second reverse each word
1. EPI6.7 Compute all mnemonics for all phone numbers
   *Given a string of int as phone number, returns all words corresponding to the phone number*
   ***
   recursive.
   ```
   get_word(digit)
    if digit == len(phone_number) # join all letters
    else:
        for c in MAPPING[int(phone_number[digit])]:
            word[digit] = c
            get_word(digit + 1)

   get_word(0)
   ```
   how about non-recursive algo?
1. EPI6.8 The look and say problem
   *Given a int n, return n-th look and say sequence in string, like  1, 11, 21, 1211, 111221, ...*
   ***
   

   

